- 2.1. Obtener el `BluetoothAdapter´


El `BluetoothAdapter`es necesario para cualquier actividad Bluetooth que se vaya a realizar. Primero se intenta obtener uno, y
en caso de que no se consiga es porque el dispositivo no es compatible con Bluetooth.

```
BluetoothAdapter mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter();
if (mBluetoothAdapter == null) {
    // Device does not support Bluetooth
}
```

Dentro del `if` habrá que poner algún mensaje pop-up de que el teléfono no soporta bluetooth y que la aplicación procede a
cerrarse, y después cerrarla. Si el dispositivo soporta Bluetooth, pero está desactivado, se puede realizar una petición al usuario para activarlo sin salir
de la aplicación.

- 2.2. Habilitar Bluetooth

A continuación tenemos que asegurarnos de que el Bluetooth está activado. Hay que llamar a `isEnabled()` para comprobar si está
activo. Si el método devuelve `false`, está desactivado. Para hacer una petición de habilitar el Bluetooth se hace una llamada a startActivityForResult() con la acción `ACTION_REQUEST_ENABLE` del `Intent` que declararemos previamente:

```
if (!mBluetoothAdapter.isEnabled()) {
    Intent enableBtIntent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE);
    startActivityForResult(enableBtIntent, REQUEST_ENABLE_BT);
}
```

Descripción de la clase `Intent`: https://developer.android.com/reference/android/content/Intent.html

Aparecerá un diálogo pidiendo al usuario habilitar Bluetooth. Si el usuario responde "Sí", el sistema comenzará a habilitar
el Bluetooth y volverá a la aplicación una vez que el proceso se haya completado (o haya fallado).

La constante `REQUEST_ENABLE_BT` pasada a `startActivityForResult()` es un entero definido localmente (que debe ser mayor que 0),
que el sistema pasa a `onActivityResult()` como parámetro `requestCode`.

Si se consigue habilitar el Bluetooth, la actividad recibe el resultado `RESULT_OK` (-1) como retorno de `onActivityResult()`.
Si no se consigue habilitar por un error o el usuario responde "No", el resultado recibido entonces es `RESULT_CANCELED` (0).

- 2.3. Encontrar dispositivos

Usando el `BluetoothAdapter`, se pueden encontrar dispositivos Bluetooth tanto por búsqueda como solicitando la lista de dispositivos vinculados. Al realizar búsqueda, cada dispositivo dentro del alcance que esté configurado como "descubrible" responderá a la petición compartiendo cierta información como el nombre del dispositivo, la clase y la dirección MAC. Con esta información, el dispositivo que realizar la búsqueda puede elegir iniciar una conexión con el dispositivo descubierto.

Cuando se realiza una conexión por primera vez, se presenta automáticamente una solicitud de emparejamiento al usuario. Al emparejar el dispositivo, se guarda la información básica (Nombre, clase, MAC) y se puede leer usando las APIs de Bluetooth. Conociendo la MAC de un dispositivo, puede iniciar una conexión con él sin necesidad de realizar una búsqueda.

*Importante*: Diferencia entre **emparejado** y **conectado**: Dos dispositivos **emparejados** conocen la existencia el uno del otro, tienen una clave de enlace (*link-key*) compartida que puede usarse para autenticación, y son capaces de establecer una conexión encriptada entre sí. Dos dispositivos **conectados** comparten un canal RFCOMM (protocolo de Bluetooth) y pueden transmitirse datos entre ellos. Las actuales APIs Bluetooth de Android requieren que los dipositivos estén emparejados antes de establecer una conexión RFCOMM (El emparejamiento se realiza automáticamente cuando inicias una conexión encriptada con las APIs de Bluetooth.

Protocolos Bluetooth: https://es.wikipedia.org/wiki/Protocolos_Bluetooth#RFCOMM

· 2.3.1. Solicitar dispositivos emparejados

Antes de realizar una búsqueda, es mejor comprobar primero si el dispositivo deseado es ya conocido. Para hacerlo, basta con una llamada a `getBondedDevices()`. Esto devolverá un conjunto de `BluetoothDevice`s representando los dispositivos emparejados. Por ejemplo, requerir los dispotivos emparejados y mostrar el nombre de cada uno al usuario usando un `ArrayAdapter` sería:

 ```
Set<BluetoothDevice> pairedDevices = mBluetoothAdapter.getBondedDevices();
// If there are paired devices
if (pairedDevices.size() > 0) {
    // Loop through paired devices
    for (BluetoothDevice device : pairedDevices) {
        // Add the name and address to an array adapter to show in a ListView
        mArrayAdapter.add(device.getName() + "\n" + device.getAddress());
    }
}
```

Lo único que necesita el objeto de la clase `BluetoothAdapter` para iniciar una conexión es la dirección MAC. En este ejemplo, se guarda como una parte de un `ArrayAdapter` que se muestra al usuario. La dirección MAC puede ser extraída posteriormente con el objetivo de iniciar la conexión.

· 2.3.2. Descubrir dispositivos

Para empezar a descubrir dispositivos, basta una llamada a `startDiscovery()`. El proceso es asíncrono y el método devolverá inmediatamente un booleano indicando si la búsqueda se ha iniciado satisfactoriamente. El proceso de búsqueda normalmente implica un escaneo de consulta (*inquiry scan*) de unos 12 segundos, seguido de un escaneo de página (*page scan*) de cada dispositivo para rescatar su nombre Bluetooth.

La aplicación debe registrar un `BroadcastReciver` para el `Intent` `ACTION_FOUND` para recibir información de cada dispositivo descubierto. Para cada dispositivo, el sistema transmitirá el `Intent` `ACTION_FOUND`. Este `Intent` lleva los campos extra `EXTRA_DEVICE` y`EXTRA_CLASS`, que contienen un `BluetoothDevice` y un `BluetoothClass`, respectivamente.

```
// Create a BroadcastReceiver for ACTION_FOUND
private final BroadcastReceiver mReceiver = new BroadcastReceiver() {
    public void onReceive(Context context, Intent intent) {
        String action = intent.getAction();
        // When discovery finds a device
        if (BluetoothDevice.ACTION_FOUND.equals(action)) {
            // Get the BluetoothDevice object from the Intent
            BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
            // Add the name and address to an array adapter to show in a ListView
            mArrayAdapter.add(device.getName() + "\n" + device.getAddress());
        }
    }
};
// Register the BroadcastReceiver
IntentFilter filter = new IntentFilter(BluetoothDevice.ACTION_FOUND);
registerReceiver(mReceiver, filter); // Don't forget to unregister during onDestroy
```

Del mismo modo que antes, lo único que necesita el objeto de la clase `BluetoothAdapter` para iniciar una conexión es la dirección MAC. En este ejemplo, al igual que en el anterior, se guarda como una parte de un `ArrayAdapter` que se muestra al usuario. La dirección MAC puede ser extraída posteriormente con el objetivo de iniciar la conexión.

- 2.4. Conectar dispositivos

El servidor debe abrir un socket de servidor y el cliente debe iniciar la conexión, usando la MAC del servidor. Cliente y servidor se consideran conectados cuando cada uno tiene conectado un `BluetoothSocket` al mismo canal RFCOMM. En este punto, ambos pueden obtener flujos de entrada y salida y la transerencia puede empezar. Cada uno obtiene el `BluetoothSocket` de distinta forma, de modo que en principio es necesario implementar tanto cliente como servidor, pero como el servidor será el módulo HC-05 que va al Arduino, sólo implementaremos la parte de cliente en nuestra App.

· 2.4.1. Conectar como cliente

Para obtener el  `BluetoothSocket` es necesario obtener previamente el `BluetoothDevice`, proceso que se explica en la sección 2.3. Este es el procedimiento básico que le sigue:

1.- Usando el `BluetoothDevice`, obtener un `BluetoothSocket` llamando a `createRfcommSocketToServiceRecord(UUID)`. Esto inicializa un `BluetoothSocket` que se conectará al `BluetoothDevice`. La UUID que se pasa como argumento debe coincidir con la UUID usada por el servidor cuando abrió su `BluetoothServerSocket` (con `listenUsingRfcommWithServiceRecord(String, UUID)` si el servidor es dispositivo Android). En el caso del HC-05, usaremos la UUID 00001101-0000-1000-8000-00805F9B34FB tal como se especifica en la página de `BluetoothDevice`: https://developer.android.com/reference/android/bluetooth/BluetoothDevice.html

2.- Iniciar la conexión con una llamada a `connect()`. Con esta llamada el sistema hará una comprobación en el dispositivo remoto para comprobar que las UUIDs coindiden. Si la comprobación es correcta y el dispositivo remoto acepta la conexión, compartirá el canal RFCOMM a usar durante la conexión y `connect()`hará *return*. Este método es una llamada de bloqueo (*blocking call*, el sistema se bloquea hasta que termina, como cuando se pide una entrada al usuario). Si por alguna razón la conexión falla o se agota el tiempo de espera de `connect()` (después de unos 12 segundos), lanzará una excepción. Al ser una *blocking call*, **este procedimiento de conexión debería siempre llevarse a cabo en un hilo** (*thread*) **separado del hijo de la actividad principal** (*mainActivity*).

Nota: Hay que asegurarse siempre de que el dispositivo no está realizando una búsqueda (descubrir dispositivos) cuando se realiza la llamada a `connect()`. Si la búsqueda está en progreso, entonces el intento de conexión se verá significativamente ralentizado y será mucho más propenso a fallar.

Ejemplo de un *thread* para iniciar la conexión:

```
private class ConnectThread extends Thread {
    private final BluetoothSocket mmSocket;
    private final BluetoothDevice mmDevice;

    public ConnectThread(BluetoothDevice device) {
        // Use a temporary object that is later assigned to mmSocket,
        // because mmSocket is final
        BluetoothSocket tmp = null;
        mmDevice = device;

        // Get a BluetoothSocket to connect with the given BluetoothDevice
        try {
            // MY_UUID is the app's UUID string, also used by the server code
            tmp = device.createRfcommSocketToServiceRecord(MY_UUID);
        } catch (IOException e) { }
        mmSocket = tmp;
    }

    public void run() {
        // Cancel discovery because it will slow down the connection
        mBluetoothAdapter.cancelDiscovery();

        try {
            // Connect the device through the socket. This will block
            // until it succeeds or throws an exception
            mmSocket.connect();
        } catch (IOException connectException) {
            // Unable to connect; close the socket and get out
            try {
                mmSocket.close();
            } catch (IOException closeException) { }
            return;
        }

        // Do work to manage the connection (in a separate thread)
        manageConnectedSocket(mmSocket);
    }

    /** Will cancel an in-progress connection, and close the socket */
    public void cancel() {
        try {
            mmSocket.close();
        } catch (IOException e) { }
    }
}
```

Nótese cómo en el ejemplo se llama a `cancelDiscovery()` antes de hacer la conexión. Debería hacerse esto siempre antes de conectar y es seguro hacerlo sin comprobar siquiera si se está ejecutando la búsqueda o no (pero si se quiere comprobar, se hace llamando a `isDiscovering()`).

`manageConnectedSocket()` es un método ficticio en el ejemplo que que iniciará el *thread* para transferir datos, que se discute en la siguiente sección.

Al terminar con el `BluetoothSocket`, siempre hay que llamar a `close()` para limpiar. Hacerlo cerrará inmediatamente el *socket* conectado y limpiará todos los recursos internos.

- 2.5. Administrar una conexión

Cuando se hayan conectado satisfactoriamente dos (o más) dispositivos, cada uno tendrá un `BluetoothSocket` conectado. Aquí es cuando se pueden compartir datos entre los dispositivos. Usando el `BluetoothSocket`, el procedimiento general para transferir datos arbitratios es simple:

1.- Obtener el `InputStream` y el `OutputStream` que manejan las transmisiones a través del *socket*, mediante `getInputStream()` y `getOutputStream()`, respectivamente.

2.- Leer y escribir datos en los flujos (*streams*) mediante `read(byte[])` y `write(byte[])`.

Eso es todo. Detalles de implementación a considerar:
Primero de todo, se debería usar un *thread* dedicado para la escritura y lectura de *streams*. Esto es importante porque ambos métodos `read(byte[])` y `write(byte[])` son *blocking calls*. `read(byte[])` bloqueará hasta que haya algo que leer del *stream*. `write(byte[])` no suele bloquear pero puede hacerlo para control de flujo si el dispositivo remoto no está llamando a `read(byte[])` suficientemente rápido y los buffers intermedios están llenos. Por tanto, el bucle principal en el *thread* debería estar dedicado a leer del `InputStream`. Un método público separado en el *thread* puede usarse para iniciar escritura en el `OutputStream`.

Un ejemplo de cómo podría ser:

```
private class ConnectedThread extends Thread {
    private final BluetoothSocket mmSocket;
    private final InputStream mmInStream;
    private final OutputStream mmOutStream;

    public ConnectedThread(BluetoothSocket socket) {
        mmSocket = socket;
        InputStream tmpIn = null;
        OutputStream tmpOut = null;

        // Get the input and output streams, using temp objects because
        // member streams are final
        try {
            tmpIn = socket.getInputStream();
            tmpOut = socket.getOutputStream();
        } catch (IOException e) { }

        mmInStream = tmpIn;
        mmOutStream = tmpOut;
    }

    public void run() {
        byte[] buffer = new byte[1024];  // buffer store for the stream
        int bytes; // bytes returned from read()

        // Keep listening to the InputStream until an exception occurs
        while (true) {
            try {
                // Read from the InputStream
                bytes = mmInStream.read(buffer);
                // Send the obtained bytes to the UI activity
                mHandler.obtainMessage(MESSAGE_READ, bytes, -1, buffer)
                        .sendToTarget();
            } catch (IOException e) {
                break;
            }
        }
    }

    /* Call this from the main activity to send data to the remote device */
    public void write(byte[] bytes) {
        try {
            mmOutStream.write(bytes);
        } catch (IOException e) { }
    }

    /* Call this from the main activity to shutdown the connection */
    public void cancel() {
        try {
            mmSocket.close();
        } catch (IOException e) { }
    }
}
```

El constructor adquiere los *streams* necesarios y, una vez ejecutado el *thread* esperará a que vengan datos a través del `InputStream`. Cuando `read(byte[])` devuelve bytes del *stream*, los datos se envían a la actividad principal usando un miembro `Handler` de la clase padre. Entonces vuelve y espera más bytes del *stream*.

Enviar datos salientes es tan simple como llamar al método `write()` del *thread* desde la actividad principal y pasarle los bytes a enviar. Este método entonces simplemente llama a `write(byte[])` para enviar los datos al dispositivo remoto.

El método `cancel()` del *thread* es importante ya que la conexión puede ser finalizada en cualquier momento mediante el cierre del `BluetoothSocket`. Este método siempre debería ser llamado cuando se ha terminado de utilizar la conexión Bluetooth.
